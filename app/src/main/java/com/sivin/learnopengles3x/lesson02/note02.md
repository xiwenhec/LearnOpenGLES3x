
# 纹理映射

本节我们来学习纹理映射

### 什么是纹理

在现实世界中,我们观察的物体都是各种形形色色的,其中`形`我们可以理解成物体的形状多种
多样,在`openGL`中,我们可以通过建模软件,为`openGL`提供各种形状的模型数组数据.
那么`色`呢,我们现实世界中的每一个物体并不是一个空白的表面,而是具有各式各样的花纹,
我们将这些花纹图案称之为纹理.

其实,这些花纹图案,就是很多密集的颜色构成,只不过她们太小,太密集,而且数据多,从整体上
观察,组成了各种各样的花纹图案.

在`OpenGL`世界中,如果想要将我们的物体模型也画上和现实世界一样细腻的花纹图案,该怎么做呢.
我们怎么办呢?有人说我们可以涂抹颜色啊,不错,是一个办法,但是现实世界中的物体表面纹理色彩
是十分细腻的,要实现和试想一下,想要完成这么多的细节,我们要成千上万这个三角形,
手动定义这么多的顶点数据时不现实的.如何为我们的模型表面,渲染出复杂细致的纹理色彩呢?

`openGL`提供了纹理映射的方式为帮助我们实现这个功能.


我们首先将`纹理图片`加载进内存中, 然后将`纹理数据`传递到`GPU`显存,如果我们有很多张纹理图片呢?
一样,如果场景需要多张纹理,我们需要将多张纹理都传递到`GPU`显存,然后,我们就可以在选择绘制哪一张纹理
但是,当纹理传递到GPU后,我们如何定位这部分纹理说数据呢,比如说,我们传递了两个纹理,`纹理A`,`纹理B`,
我们如何来控制动态的控制想要的纹理呢.`OpenGL`为我们每一个`纹理`用一个`纹理对象`来表示,获取用`纹理ID`
来和对应的`纹理对象`绑定.

### 生成纹理名字(纹理Id)

```C
/*
 * 第一个参数:想要生成的纹理数量
 * 第二个参数:存放纹理名称(纹理Id)的数组
 * 这里我们用C代码的API,在对应到java中其实差不多,参数只不过是多了一个地址偏移而已
 * 因为java中无法移动数组的地址,因此提供了一个偏移参数
 */
void glGenTextures(	GLsizei n,
 	GLuint * textures);
```

`glGenTextures`作用仅仅是表示相应的纹理名称被标记使用了,但是他的一些`状态`和`维度`都没有被分配,
这些状态只有在第一次绑定到对应的目标之后,才会被获取.为什么呢? 因为`OpenGL`此时并不知道这个纹理对象需要存放
什么类型的纹理,也就无法知晓合理的`状态`和`维度`

### 激活纹理单元

在绑定纹理之前,我们还需要做一件事,激活纹理单元,什么是纹理单元呢?顾名思义,纹理单元就是用来处理纹理贴图的模块.
能有有多少纹理单元可用,这个依赖于硬件平台的实现,`OpenGL`默认是激活(GL_TEXTURE0)纹理单元,绑定纹理操作,
其实就是告诉`OpenGL`用当前激活的纹理单元来处理该纹理.

```
glActiveTexture(GLenum texture)
```

### 将纹理名称和对应的纹理对象绑定

```C
/*
 * 第一个参数:绑定的纹理目标
 * 第二个参数:纹理名字(纹理Id)
 */
void glBindTexture(GLenum target, GLuint texture);
```

当该纹理对象第一次调用`glBindTexture`时,`OpenGL`内部就会为该纹理对象根据当前绑定的目标类型分配维度信息和状态信息.
绑定完成之后,我们就可以为当前纹理对象设置信息

### 设置纹理

>1. 设置过滤方式

```C
  glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);
  glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);
```
>2. 设置拉伸方式

纹理拉伸方式是:设这样来考虑的,比如说我们的顶点

```C
 //设置纹理S,T的拉伸方式
  glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
  glTexParameterf(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
```

上面的设置,很多书籍和博客都说了为什么这样设置,这里我就不再啰嗦了,如果不知道,可以搜索这方面的内容.

>3. 将为将纹理数据送入显存

```C

void glTexImage2D(
    GLenum target,
 	GLint level,
 	GLint internalFormat,
 	GLsizei width,
 	GLsizei height,
 	GLint border,
 	GLenum format,
 	GLenum type,
 	const GLvoid * data);
```

 >* target:当前绑定的纹理对象类型
 >* level: 纹理图细致程度.0表示基础原图,n表示第n个mipmap递减图
 >* internalFormat:纹理在`OpenGL`中存储的格式例如:GL_RGB,GL_RGBA8等,具体可以查阅API文档
 >* width:纹理的宽度
 >* height:纹理的高度
 >* border:这个值必须是0,没有理由api规定,也是历史遗留问题
 >* format:纹理内存中的存储格式
 >* type:像素数据的数据类型
 >* data:内存中的数据指针


调用玩这个函数之后,我们将就纹理从内存中传入显存中了,并且,我们可以通过,纹理的名字,来引用控制纹理的绘制渲染

我们构思一下,`OpenGL`在渲染贴图表面的时候,是如何将我们的`纹理数据`贴图到我们的模型的呢?

首先我们需要为纹理定义`纹理坐标`,然后将`纹理坐标`和对应的模型数据`顶点坐标`对应,这样纹理就会按着插值的方式为
模型的表面从合适的纹理位置选择合适的颜色值了.

将纹理颜色值采样并渲染到模型表面,在`OpenGL`中是通过一个叫`采样器`类型的对象实现的,当`采样器`和对应的纹理单元时,
采样器的状态就会被当前绑定到该纹理单元的纹理对象所接替.

采样器的存在可以使`OpenGL`有选择的绑定多个纹理对象.


