

### 什么是`Filter`

`Filter`将`Render`类的`OpenGL ES`初始化代码, 渲染绘制代码, 资源释放代码,分离出去.
这样,在同一个`OpenGL ES`渲染线程中,通过动态切换`Filter`子类对象,可以实现渲染效果的动态切换.

#### `Filter`类的上下文环境

`filter`是负责`OpenGL ES`相关的工作, 因此,凡是调用`OpenGL ES`API的代码, 必须要要保证代码运行的环境是在
`OpenGL ES`线程中,这也是`OpenGL ES`代码环境的要求

#### OpenGL视口

```java
  /**
  * 设置OpenGL视口,即:OpenGL ES渲染的窗口,这个视口的设置,是以显示容器为参考的
  * startX ,startY:表示视口起始点的位置,在android上(0,0)点在容器的左下角
  */
  GLES30.glViewport(startX, startY, width, height);
```

`GLSurfaceView`已经帮我们准备好了`OpenGL ES`渲染环境,这里`Filter`的第一步是获取`OpenGLES`着色器程序
和`shader`相关的变量句柄.

#### 获取顶点着色器的变量

`OpenGL`是一个利用`GPU`来构建,渲染和输出`3D`物体模型的`API`.

在`OpenGL`中,定义一个`3d模型`是通过一组`特定数据类型`的数据来描述的,用这个`特殊的数据类型`定义的`数据对象`我们称之为顶点(`Vertex`),
就像我们在内存中定义一个立方体,我们需要立方体的`8`个点,每个点描述的是这个点的坐标(`位置信息`)一样,`GPU`中的顶点和这个很类似,不过,这个顶点对象里描述的不仅仅
是位置(`position`)信息,还有其他的信息,例如:颜色(`color`),法线('normal`),纹理坐标`(textureCoordinate`)
等一系列的属性.

`OpenGL`渲染的流程是:
首先在内存中定义构成要渲染输出`3d模型`的一组`顶点数据`,我们将这些顶点一存放在数组里,我们称之为`顶点数组对象`,由于处理这些数据是利用`GPU`来完成的,
因此需要将这些`数据`,传递给`GPU`的显存中,数据传递完成之后,我们还有一个任务,就是告诉`GPU`改如何解释这些数据,为什么呢,因为我们定义的这些顶点,都是在
内存中的,比如说顶点的其中一个`position`属性(x,y,z)的值,用`float`来描述,但这些描述是我们告诉`CPU`改如何处理,`GPU`并不知晓,当我们把这些数据传递到
`GPU`的显存后,我们还需要告诉`GPU`这些数据的类型是什么,这个我想不用解释了.除了告诉数据类型,就完了吗? 我们还要告诉`GPU`一些信息,拿一个`顶点`来说,
这个顶点里描述了很多属性信息,`GPU`处理顶点数据,实际上是处理每个顶点里的各部分属性信息,如`坐标位置`,`颜色信息`,`法线信息`等等,一般在`shader`程序中会
定义和这些`顶点属性`对应的`变量`,因此,我们需要告诉`GPU`,`shader`中的`属性变量`对应的显存中`顶点数据`的哪一部分数据.明确了每一个变量对应的数据之后,剩下的就是
运行程序了.

其实就像一般编程一样 我们是`内存`+`CPU` ,对应的是`显存`+`GPU`,当然`内存`可能说的太严谨,因为`CPU`中有`高速缓存区`,我们通常都是关注的`内存`这个角色.这里也就不纠结这个定位了.


> 1. 获取顶点作色器中中对应变量句柄

```java
    /**
    *获取作色器变量中的句柄
    * 第一个参数:着色器程序
    * 第二个参数:顶点着色器中变量的名称
    */
    GLES30.glGetAttribLocation(mGLPro, "aPosition");
```

> 2. 将数据传递给`GPU`,同时告诉`GPU`这部分数据交给作色器中哪一个变量处理,并且告诉`GPU`该如何解释这些部分数据

```java
 /**
  * 第一个参数:着色器中变量句柄
  * 第二个参数:句柄对应变量的分量个数
  * 第三个参数:shader变量各分量的数据类型
  * 第四个参数:这块数据的总大小
  * 第五个参数:内存中的数据缓冲
  */
 GLES30.glVertexAttribPointer(
            mPosHandle,
            3,
            GLES20.GL_FLOAT,
            false,
            3 * GLESUtils.FLOAT_SIZE,
            mVertexBuffer);
```
调用了这个函数之后,内存中的顶点模型数据,就从内存中以复制的方式传递到`GPU`的显存中了

> 3. 启用顶点属性

 我们之前说过`OpenGL`中一个顶点里含有很多属性,`OpenGL`绘制渲染,也是用这些信息来完成的,但是`OpenGL`默认是将这些属性全部禁用的,
 也就说,我们必须手动的开启我们想要描述的属性,一般我们在`shader`程序中会定义很多对应的顶点属性变量,这些变量在编译成`program`的时候
 这些属性的索引存放在一个数组中,我们成这个数组为`顶点属性数组`,因此我们必须手动开启我们想要使用的顶点属性,否则这部分`顶点属性信息`就不起作用.

 ```java
    /**开启顶点属性数组中的指定的属性
    * index:属性索引,是我们glGetAttribLocation中获取的值
    */
    GLES30.glEnableVertexAttribArray(GLuint index)
 ```